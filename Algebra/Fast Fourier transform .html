<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<!-- saved from url=(0034)http://e-maxx.ru/algo/fft_multiply -->
<html class="translated-ltr"><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><title>MAXimal :: algo :: Fast Fourier transform of O (N log N).  Application to the multiplication of two polynomials or long numbers</title><meta name="author" lang="ru" content="e-maxx"><meta name="description" content="Алгоритмы, олимпиадное программирование, математика"><meta name="keywords" content="алгоритмы программирование"><link rel="stylesheet" type="text/css" href="./Fast Fourier transform _files/style.css"><script type="text/javascript" src="./Fast Fourier transform _files/jquery.js"></script><script type="text/javascript" src="./Fast Fourier transform _files/page-contents.js"></script><link rel="stylesheet" type="text/css" href="./Fast Fourier transform _files/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--><script type="text/javascript" async="" src="./Fast Fourier transform _files/embed.js"></script><link type="text/css" rel="stylesheet" charset="UTF-8" href="./Fast Fourier transform _files/translateelement.css"></head><body><div id="goog-gt-tt" class="goog-tooltip skiptranslate" dir="ltr" style="visibility: hidden; left: 426px; top: 215px; display: none;"><div style="padding: 8px;"><div><div class="logo"><img src="./Fast Fourier transform _files/translate_24dp.png" width="20" height="20"></div></div></div><div class="top" style="padding: 8px; float: left; width: 100%;"><h1 class="title gray">Original text</h1></div><div class="middle" style="padding: 8px;"><div class="original-text">Здесь мы рассмотрим алгоритм, который позволяет перемножить два полинома длиной за время , что значительно лучше времени , достигаемого тривиальным алгоритмом умножения.</div></div><div class="bottom" style="padding: 8px;"><div class="activity-links"><span class="activity-link">Contribute a better translation</span><span class="activity-link"></span></div><div class="started-activity-container"><hr style="color: #CCC; background-color: #CCC; height: 1px; border: none;"><div class="activity-root"></div></div></div><div class="status-message" style="display: none; opacity: 0;"></div></div><table class="main" cellpadding="0" cellspacing="0"><tbody><tr><td class="title" colspan="2"><p><font><font>MAXimal</font></font></p></td></tr><tr><td class="menu"><ul><li><a href="http://e-maxx.ru/index.php"><font><font>home</font></font></a></li><li><a href="http://e-maxx.ru/algo/" class="current"><font><font>algo</font></font></a></li><li><a href="http://e-maxx.ru/bookz/"><font><font>bookz</font></font></a></li><li><a href="http://e-maxx.ru/forum/"><font><font>forum</font></font></a></li><li><a href="http://e-maxx.ru/about.php"><font><font>about</font></font></a></li></ul></td><td class="content"><p class="algoinfo"><font><font>Posted on: 10 Jun 2008 19:04 </font></font><br><font><font>Edited: 9 Nov 2012 12:38</font></font></p><div id="contents-table"><p id="contents-table-title"><font><font>Contents </font></font><a href="http://e-maxx.ru/algo/fft_multiply#" id="contents-hide"><font><font>[hide]</font></font></a><a href="http://e-maxx.ru/algo/fft_multiply#" id="contents-show" style="display:none"><font><font>[view]</font></font></a></p><div><ul><li><a href="http://e-maxx.ru/algo/fft_multiply#0"><font><font>Fast Fourier transform of O (N log N). </font><font>Application to the multiplication of two polynomials or long numbers</font></font></a></li><ul><li><a href="http://e-maxx.ru/algo/fft_multiply#1"><font><font> Discrete Fourier Transform (DFT) </font></font></a></li><li><a href="http://e-maxx.ru/algo/fft_multiply#2"><font><font> Application of DFT for rapid multiplication of polynomials </font></font></a></li><li><a href="http://e-maxx.ru/algo/fft_multiply#3"><font><font> Fast Fourier transform </font></font></a></li><li><a href="http://e-maxx.ru/algo/fft_multiply#4"><font><font> Inverse FFT </font></font></a></li><li><a href="http://e-maxx.ru/algo/fft_multiply#5"><font><font> Realization </font></font></a></li><li><a href="http://e-maxx.ru/algo/fft_multiply#6"><font><font> Improved execution: calculating "in place" without additional memory </font></font></a></li><li><a href="http://e-maxx.ru/algo/fft_multiply#7"><font><font> Additional optimization </font></font></a></li><li><a href="http://e-maxx.ru/algo/fft_multiply#8"><font><font> Discrete Fourier transform in a modular arithmetic </font></font></a></li><li><a href="http://e-maxx.ru/algo/fft_multiply#9"><font><font> Some applications </font></font></a></li><ul><li><a href="http://e-maxx.ru/algo/fft_multiply#10"><font><font> All sums </font></font></a></li><li><a href="http://e-maxx.ru/algo/fft_multiply#11"><font><font> All kinds of scalar products </font></font></a></li><li><a href="http://e-maxx.ru/algo/fft_multiply#12"><font><font> Two strips </font></font></a></li></ul></ul></ul></div></div><a name="0"></a><h1 id="header_0"><font><font>Fast Fourier transform of O (N log N). </font><font>Application to the multiplication of two polynomials or long numbers</font></font></h1><p><font><font class="">Here we look at an algorithm that allows you to multiply two polynomial length </font></font><img class="tex" src="./Fast Fourier transform _files/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"><font><font class="">of time </font></font><img class="tex" src="./Fast Fourier transform _files/527d68b29319f540bf910dd5bb881008.png" alt="O (n \ log n)"><font><font class="">that is much better </font></font><img class="tex" src="./Fast Fourier transform _files/712c5a4a9bec3c435e92314194c99f95.png" alt="O (n ^ 2)"><font><font class="">time, </font><font class="">achieved a trivial multiplication algorithm. </font><font>It is obvious that the multiplication of two long numbers can be reduced to a multiplication of polynomials, so the two long numbers can also be multiplied over </font></font><img class="tex" src="./Fast Fourier transform _files/527d68b29319f540bf910dd5bb881008.png" alt="O (n \ log n)"><font><font>time.</font></font></p><p><font><font>The invention Fast Fourier Transform attributed Cooley (Coolet) and Taki (Tukey) - 1965. In fact, the FFT has repeatedly reinvent before, but its importance was not fully realized until the advent of modern computers. </font><font>Some researchers credited with the discovery of the FFT Runge (Runge) and Konig (Konig) in 1924. Finally, the discovery of this method is attributed to more Gaussian (Gauss) in 1805</font></font></p><p></p><p></p><a name="1"></a><h2 style="padding-top:40px;" id="header_1"><font><font> Discrete Fourier Transform (DFT) </font></font></h2><p><font><font>Suppose there is a </font></font><img class="tex" src="./Fast Fourier transform _files/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"><font><font>polynomial-th </font><font>degree:</font></font></p><p></p><p class="formula"><img class="tex" src="./Fast Fourier transform _files/6a5901348971c9b68cbb920419e01cd7.png" alt=" A (x) = x ^ 0 a_0 + a_1 x ^ 1 + \ ldots + a_ {n-1} x ^ {n - [...]"></p><p><font><font>Without loss of generality, we can assume that </font></font><img class="tex" src="./Fast Fourier transform _files/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"><font><font>is a power of 2. If in fact </font></font><img class="tex" src="./Fast Fourier transform _files/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"><font><font>not a power of 2, we simply add the missing factors, setting them equal to zero.</font></font></p><p><font><font>From the theory of functions of complex variable it is known that the complex roots </font></font><img class="tex" src="./Fast Fourier transform _files/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"><font><font>th of unity exists exactly </font></font><img class="tex" src="./Fast Fourier transform _files/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"><font><font>. </font><font>Denote these roots by </font></font><img class="tex" src="./Fast Fourier transform _files/ae0bb0815e9720aafd488db954490afc.png" alt="w_ {n, k}, k = 0 \ ldots {n-1}"><font><font>then it is known that </font></font><img class="tex" src="./Fast Fourier transform _files/dc368fcdcf91c93375168100816dc7d8.png" alt="w_ {n, k} = e ^ {i \ frac {2 \ pi k} {n}}"><font><font>. </font><font>In addition, one of these roots </font></font><img class="tex" src="./Fast Fourier transform _files/8afa65ef8c8ce28b1a86ae9711478925.png" alt="w_n = w_ {n, 1} = e ^ {i \ frac {2 \ pi} {n}}"><font><font>(called the principal value of the </font></font><img class="tex" src="./Fast Fourier transform _files/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"><font><font>root-th </font><font>degree of unity) is that all the other roots are its </font></font><img class="tex" src="./Fast Fourier transform _files/32a5e8ce7ba0b6d2ecffdc5151a5ce58.png" alt="w_ {n, k} = (w_n) ^ k"><font><font>powers:.</font></font></p><p><font><font>Then </font></font><b><font><font>the discrete Fourier transform (DFT)</font></font></b><font><font> (discrete Fourier transform, DFT) of a polynomial </font></font><img class="tex" src="./Fast Fourier transform _files/bfbf3a2ed6be542e1ef311ffc47b5e24.png" alt="A (x)"><font><font>(or, equivalently, the DFT of the vector of its </font></font><img class="tex" src="./Fast Fourier transform _files/2f27cab82e859df79a9fb92a7bb6967f.png" alt="(a_0, a_1, \ dots, a_ {n-1})"><font><font>coefficients) </font><font>are the values of this polynomial at the </font></font><img class="tex" src="./Fast Fourier transform _files/5f38beb12bf634779989a60db9c48071.png" alt="x = w_ {n, k}"><font><font>points, </font><font>ie </font><font>a vector:</font></font></p><p></p><p class="formula"><img class="tex" src="./Fast Fourier transform _files/e3049c4bd26ff715655bbf7c601e862a.png" alt=" {\ rm DFT} (a_0, a_1, \ ldots, a_ {n-1}) = (y_0, y_1, [...]"><br><img class="tex" src="./Fast Fourier transform _files/ddd77b9ce4f657603a42eac89a13df3d.png" alt=" = (A (w_n ^ 0), A (w_n ^ 1), \ ldots, A (w_n ^ {n-1})). "></p><p><font><font>Is defined similarly and </font></font><b><font><font>inverse discrete Fourier transform</font></font></b><font><font> (InverseDFT). </font><font>The inverse DFT for the vector of a polynomial </font></font><img class="tex" src="./Fast Fourier transform _files/a32055f2d229506c925d5641832a6e65.png" alt="(y_0, y_1, \ ldots y_ {n-1})"><font><font>- is the vector of coefficients of the </font></font><img class="tex" src="./Fast Fourier transform _files/f1110fe4590a21303ba8c627258e377d.png" alt="(a_0, a_1, \ ldots, a_ {n-1})"><font><font>polynomial:</font></font></p><p></p><p class="formula"><img class="tex" src="./Fast Fourier transform _files/7faa9281195db956b77f5d4a48ed1b50.png" alt=" {\ rm InverseDFT} (y_0, y_1, \ ldots, y_ {n-1}) = (a _ [...]"></p><p><font><font>Thus, if the direct DFT coefficients of the polynomial passes from its value in the complex roots of </font></font><img class="tex" src="./Fast Fourier transform _files/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"><font><font>th roots of unity, then inverse DFT - Conversely, restoring the values of the polynomial coefficients of the polynomial.</font></font></p><p></p><p></p><a name="2"></a><h2 style="padding-top:40px;" id="header_2"><font><font> Application of DFT for rapid multiplication of polynomials </font></font></h2><p><font><font>Consider two polynomials </font><font>and. </font><font>Calculate the DFT for each of them: </font><font>and </font><font>- two vector values of polynomials.</font></font><img class="tex" src="./Fast Fourier transform _files/b5f17df636a8bd667d2f5c3404ed82e7.png" alt="A"><font></font><img class="tex" src="./Fast Fourier transform _files/fb8234db4e6ea317a7c2aef7a38775ba.png" alt="B"><font></font><img class="tex" src="./Fast Fourier transform _files/8817f4b92fcc74baee6a5301a1bfe514.png" alt="{\ rm DFT} (A)"><font></font><img class="tex" src="./Fast Fourier transform _files/ab3fe69393e031dba8b0b046a5375fc9.png" alt="{\ rm DFT} (B)"><font></font></p><p><font><font>Now, what happens when the multiplication of polynomials? </font><font>Clearly at each point values simply multiplied, i.e.</font></font></p><p></p><p class="formula"><img class="tex" src="./Fast Fourier transform _files/51493e5c089318550f07c75ecd8ed4a1.png" alt=" (A \ times B) (x) = A (x) \ times B (x). "></p><p><font><font>But it does mean that if we multiply the vector </font></font><img class="tex" src="./Fast Fourier transform _files/8817f4b92fcc74baee6a5301a1bfe514.png" alt="{\ rm DFT} (A)"><font><font>and, simply by multiplying each element of a vector by the corresponding elements of another vector, we get nothing but how DFT of a </font><font>polynomial:</font></font><img class="tex" src="./Fast Fourier transform _files/ab3fe69393e031dba8b0b046a5375fc9.png" alt="{\ rm DFT} (B)"><font></font><img class="tex" src="./Fast Fourier transform _files/843e52c900eb5c2dea54f40be87a141c.png" alt="A \ times B"><font></font></p><p></p><p class="formula"><img class="tex" src="./Fast Fourier transform _files/602db1c065ff7cd0c78001b0c4e11453.png" alt=" {\ rm DFT} (A \ times B) = {\ rm DFT} (A) \ times {\ r [...]"></p><p><font><font>Finally, applying the inverse DFT obtain</font></font></p><p></p><p class="formula"><img class="tex" src="./Fast Fourier transform _files/a98523e9d12a30717674997fb4397a93.png" alt=" A \ times B = {\ rm InverseDFT} ({\ rm DFT} (A) \ tim [...]"></p><p><font><font>where, again, right under the product of two DFT mean pairwise products of the elements of the vectors. </font><font>This work obviously requires to compute only </font></font><img class="tex" src="./Fast Fourier transform _files/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O (n)"><font><font>operations. </font><font>Thus, if we learn how to calculate the DFT and inverse DFT of the </font></font><img class="tex" src="./Fast Fourier transform _files/527d68b29319f540bf910dd5bb881008.png" alt="O (n \ log n)"><font><font>time, </font><font>and the product of two polynomials (and, consequently, the two long numbers) we can find for the same asymptotic behavior.</font></font></p><p><font><font>It should be noted that, firstly, the result should be two polynomials of degree one (simply adding the coefficients of one of them are zero). </font><font>Secondly, as a result of the product of two polynomials of degree </font></font><img class="tex" src="./Fast Fourier transform _files/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"><font><font>obtained by a polynomial of </font></font><img class="tex" src="./Fast Fourier transform _files/072e6ac03ecf104f2cadad60066d7d36.png" alt="2n-1"><font><font>degree, </font><font>so that the result is correct, pre-need to double the degree of each polynomial (again, expanding their zero coefficients).</font></font></p><p></p><p></p><a name="3"></a><h2 style="padding-top:40px;" id="header_3"><font><font> Fast Fourier transform </font></font></h2><p><b><font><font>Fast Fourier transform</font></font></b><font><font> (fast Fourier transform) - is a method to calculate the DFT of the </font></font><img class="tex" src="./Fast Fourier transform _files/527d68b29319f540bf910dd5bb881008.png" alt="O (n \ log n)"><font><font>time. </font><font>This method is based on the properties of the complex roots of unity (namely, that some degree of give other roots roots).</font></font></p><p><font><font>The basic idea is to divide the FFT coefficient vector into two vectors, the recursive computation of the DFT for them, and combining the results into a single FFT.</font></font></p><p><font><font>So let there be a polynomial of </font></font><img class="tex" src="./Fast Fourier transform _files/bfbf3a2ed6be542e1ef311ffc47b5e24.png" alt="A (x)"><font><font>degree </font></font><img class="tex" src="./Fast Fourier transform _files/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"><font><font>where </font></font><img class="tex" src="./Fast Fourier transform _files/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"><font><font>- a power of two, </font></font><img class="tex" src="./Fast Fourier transform _files/40452ebc2b7f250462dd96af60521c95.png" alt="n&gt; 1"><font><font>and:</font></font></p><p></p><p class="formula"><img class="tex" src="./Fast Fourier transform _files/6a5901348971c9b68cbb920419e01cd7.png" alt=" A (x) = x ^ 0 a_0 + a_1 x ^ 1 + \ ldots + a_ {n-1} x ^ {n - [...]"></p><p><font><font>Divide it into two polynomials, one - with even and the other - with the odd coefficients:</font></font></p><p></p><p class="formula"><img class="tex" src="./Fast Fourier transform _files/5b804433ddd32ab8801df0b86d1e0df6.png" alt=" A_0 (x) = x ^ 0 a_0 + a_2 x ^ 1 + \ ldots + a_ {n-2} x ^ {[...]"><br><img class="tex" src="./Fast Fourier transform _files/dd58af595538c6c0daacf3b8a061bf32.png" alt=" A_1 (x) = a_1 x ^ 0 + a_3 x ^ 1 + \ ldots + a_ {n-1} x ^ {[...]"></p><p><font><font>It is easy to verify that:</font></font></p><p></p><p class="formula"><img class="tex" src="./Fast Fourier transform _files/ff0caed19983dbeb83f90d4b21fd3b1f.png" alt="A (x) = A_0 (x ^ 2) + x A_1 (x ^ 2).  ~~~~~~~ (1)"></p><p><font><font>Polynomials </font></font><img class="tex" src="./Fast Fourier transform _files/a2a21e36fabe6b4c4ee8a23807c47d78.png" alt="A_0"><font><font>and </font></font><img class="tex" src="./Fast Fourier transform _files/cbf522547b41e347e97ce35c1ff8868b.png" alt="A_1"><font><font>have twice the smaller degree than the </font></font><img class="tex" src="./Fast Fourier transform _files/b5f17df636a8bd667d2f5c3404ed82e7.png" alt="A"><font><font>polynomial. </font><font>If we can in linear time for computed </font></font><img class="tex" src="./Fast Fourier transform _files/06b525a533ef0a434f9c9dcbffb3e847.png" alt="{\ rm DFT} (A_0)"><font><font>and </font></font><img class="tex" src="./Fast Fourier transform _files/08f78588dccac67ee8e29a01ce58a2ec.png" alt="{\ rm DFT} (A_1)"><font><font>calculated, and we obtain the desired fast Fourier transform algorithm (because it is a standard chart of "divide and rule", and it is known asymptotic </font><font>estimate).</font></font><img class="tex" src="./Fast Fourier transform _files/8817f4b92fcc74baee6a5301a1bfe514.png" alt="{\ rm DFT} (A)"><font></font><img class="tex" src="./Fast Fourier transform _files/527d68b29319f540bf910dd5bb881008.png" alt="O (n \ log n)"><font></font></p><p><font><font>So, suppose we have calculated the vector </font><font>and. </font><font>We find </font><font>expressions.</font></font><img class="tex" src="./Fast Fourier transform _files/d668973caa5f4f8defcd67e6e0d40755.png" alt="\ {Y_k ^ 0 \} _ {k = 0} ^ {n / 2-1} = {\ rm DFT} (A_0)"><font></font><img class="tex" src="./Fast Fourier transform _files/fdea6d6006054cb35de613d583f40b31.png" alt="\ {Y_k ^ 1 \} _ {k = 0} ^ {n / 2-1} = {\ rm DFT} (A_1)"><font></font><img class="tex" src="./Fast Fourier transform _files/18c5b5d6a4e7a567dc5331ce74d92886.png" alt="\ {Y_k \} _ {k = 0} ^ {n-1} = {\ rm DFT} (A)"><font></font></p><p><font><font>Firstly, recalling (1), we immediately obtain the values for the first half of factors:</font></font></p><p></p><p class="formula"><img class="tex" src="./Fast Fourier transform _files/2f6d61e44ea21c2ba95b023c513af4b7.png" alt=" y_k = y_k ^ 0 + w_n ^ k y_k ^ 1, ~~~~ k = 0 \ ldots n / 2-1 [...]"></p><p><font><font>For the second half of the coefficients after transformation also get a simple formula:</font></font></p><p></p><p class="formula"><img class="tex" src="./Fast Fourier transform _files/a56e5dc055fc96ced1531419311416c1.png" alt=" y_ {k + n / 2} = A (w_n ^ {k + n / 2}) = A_0 (w_n ^ {2k + n}) + w _ [...]"><br><img class="tex" src="./Fast Fourier transform _files/321b8a486b2d89963b5c9d11e7b6f8ce.png" alt=" = A_0 (w_n ^ {2k}) - w_n ^ k A_1 (w_n ^ {2k}) = y_k ^ 0 - w [...]"></p><p><font><font>(Here we have used (1) as well as </font><font>identities,.)</font></font><img class="tex" src="./Fast Fourier transform _files/881ca23330d9e4d651c116dd154f3748.png" alt="w_n ^ n = 1"><font></font><img class="tex" src="./Fast Fourier transform _files/e55ff0206822dc65547b211cc2c200c2.png" alt="w_n ^ {n / 2} = -1"><font></font></p><p><font><font>So as a result we got the formula for calculating the total of the </font></font><img class="tex" src="./Fast Fourier transform _files/3fb0039dd19d9bf8cded34b4c935f724.png" alt="\ {Y_k \}"><font><font>vector:</font></font></p><p></p><p class="formula"><img class="tex" src="./Fast Fourier transform _files/040823e5aa878991074cef09c28cbcc4.png" alt=" y_k = y_k ^ 0 + w_n ^ k y_k ^ 1, \ \ \ \ k = 0 \ ldots n [...]"><br><img class="tex" src="./Fast Fourier transform _files/52f6ad5dc4ea216a05ab0fdcf42fea94.png" alt=" y_ {k + n / 2} = y_k ^ 0 - w_n ^ k y_k ^ 1, \ \ \ \ k = 0 \ l [...]"></p><p><font><font>(these formulas, that is, two kinds of </font></font><img class="tex" src="./Fast Fourier transform _files/d239542aeb46cc04bda21c01dc8a21ec.png" alt="a + bc"><font><font>formula, </font><font>and, sometimes referred to as "the transformation of the butterfly" ("butterfly operation"))</font></font><img class="tex" src="./Fast Fourier transform _files/064f5c1480977040b3ca966433c576d3.png" alt="a-bc"><font></font></p><p><font><font>Thus, we finally built the FFT algorithm.</font></font></p><p></p><p></p><a name="4"></a><h2 style="padding-top:40px;" id="header_4"><font><font> Inverse FFT </font></font></h2><p><font><font>So, let the vector is given </font></font><img class="tex" src="./Fast Fourier transform _files/5705597992b789ba6aa7f68851575d92.png" alt="(y_0, y_1, \ ldots, y_ {n-1})"><font><font>- the value of the polynomial </font></font><img class="tex" src="./Fast Fourier transform _files/b5f17df636a8bd667d2f5c3404ed82e7.png" alt="A"><font><font>degree </font></font><img class="tex" src="./Fast Fourier transform _files/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"><font><font>in </font></font><img class="tex" src="./Fast Fourier transform _files/32b7839b46ba4ff3051d1e6c0fc38050.png" alt="x = w_n ^ k"><font><font>points. </font><font>You need to restore the coefficients </font></font><img class="tex" src="./Fast Fourier transform _files/f1110fe4590a21303ba8c627258e377d.png" alt="(a_0, a_1, \ ldots, a_ {n-1})"><font><font>of the polynomial. </font><font>This well-known problem is called </font></font><b><font><font>interpolation, for this task, there are some common algorithms for the solution, but in this case will get a very simple algorithm (simple fact that it does not differ from the forward FFT).</font></font></b><font></font></p><p><font><font>DFT can be written, according to his definition, in matrix form:</font></font></p><p></p><p class="formula"><img class="tex" src="./Fast Fourier transform _files/b55df3e3ca59f857d8cb3d60aebdee4e.png" alt=" \ pmatrix {w_n ^ 0 0 &amp; w_n ^ &amp; w_n ^ 0 0 &amp; w_n ^ &amp; \ cdots [...]"></p><p><font><font>The vector </font></font><img class="tex" src="./Fast Fourier transform _files/f1110fe4590a21303ba8c627258e377d.png" alt="(a_0, a_1, \ ldots, a_ {n-1})"><font><font>can be found by multiplying the vector </font></font><img class="tex" src="./Fast Fourier transform _files/5705597992b789ba6aa7f68851575d92.png" alt="(y_0, y_1, \ ldots, y_ {n-1})"><font><font>by an inverse matrix to the matrix on the left (which, incidentally, is called Vandermonde matrix):</font></font></p><p></p><p class="formula"><img class="tex" src="./Fast Fourier transform _files/a2423a3d733522b775e18632a4dbe74d.png" alt=" \ pmatrix {a_0 \ cr a_1 \ cr a_2 \ cr a_3 \ cr \ vdots [...]"></p><p><font><font>A direct check that the inverse matrix as follows:</font></font></p><p></p><p class="formula"><img class="tex" src="./Fast Fourier transform _files/436ce57811714289fc98a5f9502fa35b.png" alt=" \ frac {1} {n} \ pmatrix {w_n ^ 0 0 &amp; w_n ^ &amp; w_n ^ 0 &amp; w_n [...]"></p><p><font><font>Thus, we obtain:</font></font></p><p></p><p class="formula"><img class="tex" src="./Fast Fourier transform _files/2e40264ef544517ae369e48475c42615.png" alt=" a_k = \ frac {1} {n} \ sum_ {j = 0} ^ {n-1} y_j w_n ^ {- kj}. [...]"></p><p><font><font>Comparing it with the formula </font></font><img class="tex" src="./Fast Fourier transform _files/134a7d3afcf0f1246e5e9b3af50ba87b.png" alt="y_k"><font><font>for:</font></font></p><p></p><p class="formula"><img class="tex" src="./Fast Fourier transform _files/f768653457b54c5fb971b44486468e81.png" alt=" y_k = \ sum_ {j = 0} ^ {n-1} a_j w_n ^ {kj}, "></p><p><font><font>we see that these two problems are almost indistinguishable, so the coefficients </font></font><img class="tex" src="./Fast Fourier transform _files/f74cd5e7479be5ae104fef83192347a1.png" alt="a_k"><font><font>can be found in the same algorithm of "divide and rule" as a direct FFT, only instead of </font></font><img class="tex" src="./Fast Fourier transform _files/0761653b7b8ed54ddce7240e4572145d.png" alt="w_n ^ k"><font><font>all it is necessary to </font></font><img class="tex" src="./Fast Fourier transform _files/538de2f61b798f389f48b21ae2b3eada.png" alt="w_n ^ {- k}"><font><font>use, </font><font>and each element of the result should be divided </font></font><img class="tex" src="./Fast Fourier transform _files/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"><font><font>into.</font></font></p><p><font><font>Thus, the calculation of the inverse DFT is almost indistinguishable from a direct computation of the DFT, and can also be performed </font></font><img class="tex" src="./Fast Fourier transform _files/527d68b29319f540bf910dd5bb881008.png" alt="O (n \ log n)"><font><font>during.</font></font></p><p></p><p></p><a name="5"></a><h2 style="padding-top:40px;" id="header_5"><font><font> Realization </font></font></h2><p><font><font>Consider a simple recursive </font></font><b><font><font>implementation of the FFT</font></font></b><font><font> and inverse FFT, realize them in the form of a single function, since the differences between the direct and inverse FFT low. </font><font>For storing complex numbers to use standard C ++ STL type complex (defined in the header file &lt;complex&gt;).</font></font></p><p></p><pre class="notranslate cpp"><span class="kw4">typedef</span> complex<span class="sy1">&lt;</span><span class="kw4">double</span><span class="sy1">&gt;</span> base<span class="sy4">;</span>
&nbsp;
<span class="kw4">void</span> fft <span class="br0">(</span>vector<span class="sy1">&lt;</span>base<span class="sy1">&gt;</span> <span class="sy3">&amp;</span> a, <span class="kw4">bool</span> invert<span class="br0">)</span> <span class="br0">{</span>
	<span class="kw4">int</span> n <span class="sy1">=</span> <span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> a.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">(</span>n <span class="sy1">==</span> <span class="nu0">1</span><span class="br0">)</span>  <span class="kw1">return</span><span class="sy4">;</span>
&nbsp;
	vector<span class="sy1">&lt;</span>base<span class="sy1">&gt;</span> a0 <span class="br0">(</span>n<span class="sy2">/</span><span class="nu0">2</span><span class="br0">)</span>,  a1 <span class="br0">(</span>n<span class="sy2">/</span><span class="nu0">2</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span>, j<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> i<span class="sy2">+</span><span class="sy1">=</span><span class="nu0">2</span>, <span class="sy2">++</span>j<span class="br0">)</span> <span class="br0">{</span>
		a0<span class="br0">[</span>j<span class="br0">]</span> <span class="sy1">=</span> a<span class="br0">[</span>i<span class="br0">]</span><span class="sy4">;</span>
		a1<span class="br0">[</span>j<span class="br0">]</span> <span class="sy1">=</span> a<span class="br0">[</span>i<span class="sy2">+</span><span class="nu0">1</span><span class="br0">]</span><span class="sy4">;</span>
	<span class="br0">}</span>
	fft <span class="br0">(</span>a0, invert<span class="br0">)</span><span class="sy4">;</span>
	fft <span class="br0">(</span>a1, invert<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="kw4">double</span> ang <span class="sy1">=</span> <span class="nu0">2</span><span class="sy2">*</span>PI<span class="sy2">/</span>n <span class="sy2">*</span> <span class="br0">(</span>invert <span class="sy4">?</span> <span class="sy2">-</span><span class="nu0">1</span> <span class="sy4">:</span> <span class="nu0">1</span><span class="br0">)</span><span class="sy4">;</span>
	base w <span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span>,  wn <span class="br0">(</span><span class="kw3">cos</span><span class="br0">(</span>ang<span class="br0">)</span>, <span class="kw3">sin</span><span class="br0">(</span>ang<span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy2">/</span><span class="nu0">2</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">)</span> <span class="br0">{</span>
		a<span class="br0">[</span>i<span class="br0">]</span> <span class="sy1">=</span> a0<span class="br0">[</span>i<span class="br0">]</span> <span class="sy2">+</span> w <span class="sy2">*</span> a1<span class="br0">[</span>i<span class="br0">]</span><span class="sy4">;</span>
		a<span class="br0">[</span>i<span class="sy2">+</span>n<span class="sy2">/</span><span class="nu0">2</span><span class="br0">]</span> <span class="sy1">=</span> a0<span class="br0">[</span>i<span class="br0">]</span> <span class="sy2">-</span> w <span class="sy2">*</span> a1<span class="br0">[</span>i<span class="br0">]</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">(</span>invert<span class="br0">)</span>
			a<span class="br0">[</span>i<span class="br0">]</span> <span class="sy2">/</span><span class="sy1">=</span> <span class="nu0">2</span>,  a<span class="br0">[</span>i<span class="sy2">+</span>n<span class="sy2">/</span><span class="nu0">2</span><span class="br0">]</span> <span class="sy2">/</span><span class="sy1">=</span> <span class="nu0">2</span><span class="sy4">;</span>
		w <span class="sy2">*</span><span class="sy1">=</span> wn<span class="sy4">;</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre><p><font><font>The argument </font></font><img class="tex" src="./Fast Fourier transform _files/bf8b70d760786cee9c0906bcf01cf666.png" alt="\ rm a"><font><font>function is passed an input vector of coefficients, there also will contain the results. </font><font>The argument </font></font><img class="tex" src="./Fast Fourier transform _files/55b7ec4ceabb3769220549936beba27f.png" alt="\ rm invert"><font><font>indicates direct or inverse DFT should be calculated. </font><font>Inside the function first checks if the vector length </font></font><img class="tex" src="./Fast Fourier transform _files/bf8b70d760786cee9c0906bcf01cf666.png" alt="\ rm a"><font><font>is equal to one, then nothing else to do - he is the answer. </font><font>Otherwise, the vector </font></font><img class="tex" src="./Fast Fourier transform _files/bf8b70d760786cee9c0906bcf01cf666.png" alt="\ rm a"><font><font>is split into two </font></font><img class="tex" src="./Fast Fourier transform _files/9d6d876f7afec666a89e210f108d9620.png" alt="\ rm a0"><font><font>vectors, </font><font>and </font></font><img class="tex" src="./Fast Fourier transform _files/2b4c651910283fed8824668a51b71471.png" alt="\ rm a1"><font><font>for which the DFT is calculated recursively. </font><font>It then calculates the value </font></font><img class="tex" src="./Fast Fourier transform _files/f12b737c8c65734e041f13f902fce36a.png" alt="w_n"><font><font>of, </font><font>and plants a variable </font></font><img class="tex" src="./Fast Fourier transform _files/fee0bf4308e5ab449d0ff8518fb4207e.png" alt="w"><font><font>containing the current </font></font><img class="tex" src="./Fast Fourier transform _files/f12b737c8c65734e041f13f902fce36a.png" alt="w_n"><font><font>level. </font><font>Then calculate the elements of the result of the above formulas DFT.</font></font></p><p><font><font>If the flag is </font></font><img class="tex" src="./Fast Fourier transform _files/a3b410c91e279644c05e4033253073b2.png" alt="\ rm invert = true"><font><font>specified, </font><font>it </font></font><img class="tex" src="./Fast Fourier transform _files/f12b737c8c65734e041f13f902fce36a.png" alt="w_n"><font><font>is replaced </font></font><img class="tex" src="./Fast Fourier transform _files/e42ff37eaeded937d425915bec3785f4.png" alt="w_n ^ {- 1}"><font><font>by, </font><font>and each element of the result is divided by 2 (assuming that the division by 2 will take place in each level of recursion, then eventually just turns out that all the elements are divided </font></font><img class="tex" src="./Fast Fourier transform _files/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"><font><font>into).</font></font></p><p><font><font>Then the function for </font></font><b><font><font>multiplying two polynomials</font></font></b><font><font> will be as follows:</font></font></p><p></p><pre class="notranslate cpp"><span class="kw4">void</span> multiply <span class="br0">(</span><span class="kw4">const</span> vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> <span class="sy3">&amp;</span> a, <span class="kw4">const</span> vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> <span class="sy3">&amp;</span> b, vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> <span class="sy3">&amp;</span> res<span class="br0">)</span> <span class="br0">{</span>
	vector<span class="sy1">&lt;</span>base<span class="sy1">&gt;</span> fa <span class="br0">(</span>a.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span>, a.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>,  fb <span class="br0">(</span>b.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span>, b.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="kw4">size_t</span> n <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
	<span class="kw1">while</span> <span class="br0">(</span>n <span class="sy1">&lt;</span> max <span class="br0">(</span>a.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span>, b.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>  n <span class="sy1">&lt;&lt;=</span> <span class="nu0">1</span><span class="sy4">;</span>
	n <span class="sy1">&lt;&lt;=</span> <span class="nu0">1</span><span class="sy4">;</span>
	fa.<span class="me1">resize</span> <span class="br0">(</span>n<span class="br0">)</span>,  fb.<span class="me1">resize</span> <span class="br0">(</span>n<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	fft <span class="br0">(</span>fa, <span class="kw2">false</span><span class="br0">)</span>,  fft <span class="br0">(</span>fb, <span class="kw2">false</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">size_t</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">)</span>
		fa<span class="br0">[</span>i<span class="br0">]</span> <span class="sy2">*</span><span class="sy1">=</span> fb<span class="br0">[</span>i<span class="br0">]</span><span class="sy4">;</span>
	fft <span class="br0">(</span>fa, <span class="kw2">true</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	res.<span class="me1">resize</span> <span class="br0">(</span>n<span class="br0">)</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">size_t</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">)</span>
		res<span class="br0">[</span>i<span class="br0">]</span> <span class="sy1">=</span> <span class="kw4">int</span> <span class="br0">(</span>fa<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">real</span><span class="br0">(</span><span class="br0">)</span> <span class="sy2">+</span> <span class="nu16">0.5</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre><p><font><font>This function works with polynomials with integer coefficients (although, of course, in theory, nothing prevents her work with fractional-N). </font><font>However, there appears the problem of a large error in the calculation of the DFT: the error can be significant, so the rounding of the best most reliable way - adding 0.5 and then rounding down </font></font><b><font><font>(note:</font></font></b><font><font> it will not work properly for negative numbers, if any, may occur in your application).</font></font></p><p><font><font>Finally, the function for </font></font><b><font><font>multiplying two long numbers</font></font></b><font><font> practically does not differ from the function for multiplication of polynomials. </font><font>The only feature - that after the multiplication of numbers as polynomials should be normalized, ie </font><font>perform all transfers bits:</font></font></p><p></p><pre class="notranslate cpp">	<span class="kw4">int</span> carry <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">size_t</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">)</span> <span class="br0">{</span>
		res<span class="br0">[</span>i<span class="br0">]</span> <span class="sy2">+</span><span class="sy1">=</span> carry<span class="sy4">;</span>
		carry <span class="sy1">=</span> res<span class="br0">[</span>i<span class="br0">]</span> <span class="sy2">/</span> <span class="nu0">10</span><span class="sy4">;</span>
		res<span class="br0">[</span>i<span class="br0">]</span> <span class="sy2">%</span><span class="sy1">=</span> <span class="nu0">10</span><span class="sy4">;</span>
	<span class="br0">}</span></pre><p><font><font>(Since the length of the product of two numbers will never surpass the total length of numbers, the size of the vector </font></font><img class="tex" src="./Fast Fourier transform _files/085b69d1bd01278654eebf737d429b9a.png" alt="\ rm res"><font><font>will be enough to carry out all translations.)</font></font></p><p></p><p></p><a name="6"></a><h2 style="padding-top:40px;" id="header_6"><font><font> Improved execution: calculating "in place" without additional memory </font></font></h2><p><font><font>To increase the efficiency abandon recursion explicitly. </font><font>In the above recursive implementation, we clearly shared the vector </font></font><img class="tex" src="./Fast Fourier transform _files/bf8b70d760786cee9c0906bcf01cf666.png" alt="\ rm a"><font><font>into two vectors - the elements on even positions attributed to the same time creates a vector, and on odd - to another. </font><font>However, if we reorder elements in a certain way, the need for a temporary vectors would then be eliminated (ie, all the calculations we could produce "on the spot", right in the </font></font><img class="tex" src="./Fast Fourier transform _files/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"><font><font>vector).</font></font></p><p><font><font>Note that the first level of recursion elements younger (first) position bits are zero, refer to the </font></font><img class="tex" src="./Fast Fourier transform _files/f356b4e4422ce4fce9cd16686f0ca8ef.png" alt="a_0"><font><font>vector, </font><font>and the least significant bits are equal to one position - to the </font></font><img class="tex" src="./Fast Fourier transform _files/72c05ff251132298d5760955158f1052.png" alt="a_1"><font><font>vector. </font><font>On the second level of recursion is done the same thing, but for the second bit, etc. </font><font>Therefore, if we are in the position </font></font><img class="tex" src="./Fast Fourier transform _files/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"><font><font>of each element </font></font><img class="tex" src="./Fast Fourier transform _files/3530c8c1281c8ee618b020a2333a22ca.png" alt="a [i]"><font><font>invert the order of the bits, and reorder elements in an array </font></font><img class="tex" src="./Fast Fourier transform _files/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"><font><font>according to the new index, we obtain the desired order (called </font></font><b><font><font>bitwise inverse permutation</font></font></b><font><font> (bit-reversal permutation)).</font></font></p><p><font><font>For example, in </font></font><img class="tex" src="./Fast Fourier transform _files/1773f914f4444e282c8f936249b6edb9.png" alt="n = 8"><font><font>this order is as follows:</font></font></p><p></p><p class="formula"><img class="tex" src="./Fast Fourier transform _files/64d2b150180449b21a63ef4fe93b646f.png" alt=" a = \ biggl \ {\ Bigl [(a_0, a_4), (a_2, a_6) \ Bigr] [...]"></p><p><font><font>Indeed, at the first level of recursion (surrounded by curly braces) conventional recursive algorithm is a division of the vector into two parts, </font><font>and. </font><font>As we can see in the back bit by bit permutation, this corresponds to a separation of the vector into two halves: the first </font><font>element and the last </font><font>element. </font><font>Then the recursive call of each half; </font><font>suppose DFT resulting from each of these was returned to the place of the elements themselves (i.e., the first and second halves of the </font><font>vectors, </font><font>respectively):</font></font><img class="tex" src="./Fast Fourier transform _files/46746c25c4cce21e8001214cccce7a53.png" alt="[a_0, a_2, a_4, a_6]"><font></font><img class="tex" src="./Fast Fourier transform _files/150638cbc6a10b0083affd00b788daac.png" alt="[a_1, a_3, a_5, a_7]"><font></font><img class="tex" src="./Fast Fourier transform _files/48b1c5206b1d914c2ec894c9078c06ca.png" alt="n / 2"><font></font><img class="tex" src="./Fast Fourier transform _files/48b1c5206b1d914c2ec894c9078c06ca.png" alt="n / 2"><font></font><img class="tex" src="./Fast Fourier transform _files/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"><font></font></p><p></p><p class="formula"><img class="tex" src="./Fast Fourier transform _files/5d71a8ccf515388c91ae4c988a55ac37.png" alt=" a = \ biggl \ {\ Bigl [y_0 ^ 0, \ y_1 ^ 0, \ y_2 ^ 0, \ y_3 ^ 0 [...]"></p><p><font><font>Now we need to perform a union of two into one DFT for the entire vector. </font><font>But the elements stood out so well that the union can be performed directly in the array. </font><font>Indeed, we take the elements </font></font><img class="tex" src="./Fast Fourier transform _files/848d90a7136f50999e99e8606d3a27eb.png" alt="y_0 ^ 0"><font><font>and </font></font><img class="tex" src="./Fast Fourier transform _files/b0a3837fb349b723518cc8389f5dfe79.png" alt="y_0 ^ 1"><font><font>by applying the conversion butterfly, and the result is put in their place - and this place and would thus, which should have been received:</font></font></p><p></p><p class="formula"><img class="tex" src="./Fast Fourier transform _files/c8dd2788449848cb4ffc2ba85317a264.png" alt=" a = \ biggl \ {\ Bigl [y_0 ^ 0 + w_n ^ 0y_0 ^ 1, \ y_1 ^ 0, \ y _ [...]"></p><p><font><font>Similarly, the transformation is applied to the butterfly </font></font><img class="tex" src="./Fast Fourier transform _files/2b7fd2de2a85f89064f84383b9414437.png" alt="y_1 ^ 0"><font><font>and </font></font><img class="tex" src="./Fast Fourier transform _files/f1a53d88dbafd8315a52d6333951f816.png" alt="y_1 ^ 1"><font><font>the result put in their place, etc. </font><font>As a result, we get:</font></font></p><p></p><p class="formula"><img class="tex" src="./Fast Fourier transform _files/1178444e053e39067b1b5900f9780e04.png" alt=" a = \ biggl \ {\ Bigl [y_0 ^ 0 + w_n ^ 0y_0 ^ 1, \ y_1 ^ 0 + w_n ^ [...]"><br><img class="tex" src="./Fast Fourier transform _files/9f0332cff11837832089ba53fb0c833f.png" alt=" ~~~~~~~~ \ Bigl [y_0 ^ 0-w_n ^ 0y_0 ^ 1, \ y_1 ^ 0-w_n ^ 1y_1 [...]"></p><p><font><font>Ie </font><font>we got exactly the desired DFT of the </font></font><img class="tex" src="./Fast Fourier transform _files/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"><font><font>vector.</font></font></p><p><font><font>We describe the process of calculating the DFT at the first level of recursion, but it is clear that the same considerations are also valid for all other levels of recursion. </font><font>Thus, </font></font><b><font><font>after applying bitwise inverse DFT to calculate the permutations possible in </font></font></b><font><font>place, </font><font>without additional arrays.</font></font></p><p><font><font>But now you can </font></font><b><font><font>get rid of the recursion</font></font></b><font><font> explicitly. </font><font>So, we used the bitwise inverse permutation elements. </font><font>Now perform all the work performed by the lower level of recursion, ie </font><font>vector </font></font><img class="tex" src="./Fast Fourier transform _files/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"><font><font>divide into pairs of elements for each butterfly apply the transformation, resulting in the vector </font></font><img class="tex" src="./Fast Fourier transform _files/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"><font><font>will be the results of lower level of recursion. </font><font>In the next step we divide the vector </font></font><img class="tex" src="./Fast Fourier transform _files/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"><font><font>at Four elements applicable to each butterfly transformation, to obtain the DFT for each four. </font><font>And so on, finally, the last step, we received the results of the DFT for the two halves of the </font></font><img class="tex" src="./Fast Fourier transform _files/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"><font><font>vector, </font><font>it is applicable to the transformation of butterflies and get the DFT for the entire </font></font><img class="tex" src="./Fast Fourier transform _files/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"><font><font>vector.</font></font></p><p><font><font>Thus, the implementation of:</font></font></p><p></p><pre class="notranslate cpp"><span class="kw4">typedef</span> complex<span class="sy1">&lt;</span><span class="kw4">double</span><span class="sy1">&gt;</span> base<span class="sy4">;</span>
&nbsp;
<span class="kw4">int</span> rev <span class="br0">(</span><span class="kw4">int</span> num, <span class="kw4">int</span> lg_n<span class="br0">)</span> <span class="br0">{</span>
	<span class="kw4">int</span> res <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>lg_n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">)</span>
		<span class="kw1">if</span> <span class="br0">(</span>num <span class="sy3">&amp;</span> <span class="br0">(</span><span class="nu0">1</span><span class="sy1">&lt;&lt;</span>i<span class="br0">)</span><span class="br0">)</span>
			res <span class="sy3">|</span><span class="sy1">=</span> <span class="nu0">1</span><span class="sy1">&lt;&lt;</span><span class="br0">(</span>lg_n<span class="sy2">-</span><span class="nu0">1</span><span class="sy2">-</span>i<span class="br0">)</span><span class="sy4">;</span>
	<span class="kw1">return</span> res<span class="sy4">;</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">void</span> fft <span class="br0">(</span>vector<span class="sy1">&lt;</span>base<span class="sy1">&gt;</span> <span class="sy3">&amp;</span> a, <span class="kw4">bool</span> invert<span class="br0">)</span> <span class="br0">{</span>
	<span class="kw4">int</span> n <span class="sy1">=</span> <span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> a.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="kw4">int</span> lg_n <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
	<span class="kw1">while</span> <span class="br0">(</span><span class="br0">(</span><span class="nu0">1</span> <span class="sy1">&lt;&lt;</span> lg_n<span class="br0">)</span> <span class="sy1">&lt;</span> n<span class="br0">)</span>  <span class="sy2">++</span>lg_n<span class="sy4">;</span>
&nbsp;
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">)</span>
		<span class="kw1">if</span> <span class="br0">(</span>i <span class="sy1">&lt;</span> rev<span class="br0">(</span>i,lg_n<span class="br0">)</span><span class="br0">)</span>
			swap <span class="br0">(</span>a<span class="br0">[</span>i<span class="br0">]</span>, a<span class="br0">[</span>rev<span class="br0">(</span>i,lg_n<span class="br0">)</span><span class="br0">]</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> len<span class="sy1">=</span><span class="nu0">2</span><span class="sy4">;</span> len<span class="sy1">&lt;=</span>n<span class="sy4">;</span> len<span class="sy1">&lt;&lt;=</span><span class="nu0">1</span><span class="br0">)</span> <span class="br0">{</span>
		<span class="kw4">double</span> ang <span class="sy1">=</span> <span class="nu0">2</span><span class="sy2">*</span>PI<span class="sy2">/</span>len <span class="sy2">*</span> <span class="br0">(</span>invert <span class="sy4">?</span> <span class="sy2">-</span><span class="nu0">1</span> <span class="sy4">:</span> <span class="nu0">1</span><span class="br0">)</span><span class="sy4">;</span>
		base wlen <span class="br0">(</span><span class="kw3">cos</span><span class="br0">(</span>ang<span class="br0">)</span>, <span class="kw3">sin</span><span class="br0">(</span>ang<span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> i<span class="sy2">+</span><span class="sy1">=</span>len<span class="br0">)</span> <span class="br0">{</span>
			base w <span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy4">;</span>
			<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> j<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> j<span class="sy1">&lt;</span>len<span class="sy2">/</span><span class="nu0">2</span><span class="sy4">;</span> <span class="sy2">++</span>j<span class="br0">)</span> <span class="br0">{</span>
				base u <span class="sy1">=</span> a<span class="br0">[</span>i<span class="sy2">+</span>j<span class="br0">]</span>,  v <span class="sy1">=</span> a<span class="br0">[</span>i<span class="sy2">+</span>j<span class="sy2">+</span>len<span class="sy2">/</span><span class="nu0">2</span><span class="br0">]</span> <span class="sy2">*</span> w<span class="sy4">;</span>
				a<span class="br0">[</span>i<span class="sy2">+</span>j<span class="br0">]</span> <span class="sy1">=</span> u <span class="sy2">+</span> v<span class="sy4">;</span>
				a<span class="br0">[</span>i<span class="sy2">+</span>j<span class="sy2">+</span>len<span class="sy2">/</span><span class="nu0">2</span><span class="br0">]</span> <span class="sy1">=</span> u <span class="sy2">-</span> v<span class="sy4">;</span>
				w <span class="sy2">*</span><span class="sy1">=</span> wlen<span class="sy4">;</span>
			<span class="br0">}</span>
		<span class="br0">}</span>
	<span class="br0">}</span>
	<span class="kw1">if</span> <span class="br0">(</span>invert<span class="br0">)</span>
		<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">)</span>
			a<span class="br0">[</span>i<span class="br0">]</span> <span class="sy2">/</span><span class="sy1">=</span> n<span class="sy4">;</span>
<span class="br0">}</span>
&nbsp;</pre><p><font><font>First, a vector </font></font><img class="tex" src="./Fast Fourier transform _files/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"><font><font>is used bit by bit reverse permutation, which calculates the number of significant bits </font></font><img class="tex" src="./Fast Fourier transform _files/5c4ea7d0a9d2f455c81228570ea1bdf1.png" alt="\ rm lg \ _n"><font><font>() </font><font>including, for each position </font><font>is corresponding position bit which has a bit entry record number </font><font>recorded in the reverse order. </font><font>If the resulting position was </font><font>greater, </font><font>the elements in the two positions should be exchanged (if not this condition, each couple will exchange twice and in the end nothing happens).</font></font><img class="tex" src="./Fast Fourier transform _files/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"><font></font><img class="tex" src="./Fast Fourier transform _files/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"><font></font><img class="tex" src="./Fast Fourier transform _files/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"><font></font><img class="tex" src="./Fast Fourier transform _files/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"><font></font></p><p><font><font>Then, the </font></font><img class="tex" src="./Fast Fourier transform _files/23176441ed4c7dcbd41a23de28abea36.png" alt="\ lg n - 1"><font><font>steps of the algorithm on </font></font><img class="tex" src="./Fast Fourier transform _files/252410059470b019db6fd4c3b844a348.png" alt="k"><font><font>th of which </font></font><img class="tex" src="./Fast Fourier transform _files/7da079f1920effd7e8802d7f3cb8e481.png" alt="k = 2 \ ldots \ lg n"><font><font>() </font><font>are computed for the DFT block </font></font><img class="tex" src="./Fast Fourier transform _files/a631b6ee74bdfc6711813da7ca95a648.png" alt="2 ^ k"><font><font>length. </font><font>For all of these units will be the same value of a primitive </font></font><img class="tex" src="./Fast Fourier transform _files/9a7bfc843a91062f48df6a61cc049563.png" alt="w_ {2 ^ k}"><font><font>root, </font><font>and is stored in a </font></font><img class="tex" src="./Fast Fourier transform _files/867b01a3802da1e476dc7a7743d664d2.png" alt="\ rm wlen"><font><font>variable. </font><font>Loop through </font></font><img class="tex" src="./Fast Fourier transform _files/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"><font><font>is iterated for blocks, and embedded in a cycle of </font></font><img class="tex" src="./Fast Fourier transform _files/f2761432c5377ee4ded848884be6d407.png" alt="j"><font><font>applying the transformation of butterflies to all elements of the unit.</font></font></p><p><font><font>You can further </font></font><b><font><font>optimize the bit </font></font></b><font><font>reverse. </font><font>In the previous implementation, we were obviously all the bits of the number, digit by digit inverted passing order number. </font><font>However, reversing the bits can be performed in a different way.</font></font></p><p><font><font>For example, suppose </font></font><img class="tex" src="./Fast Fourier transform _files/f2761432c5377ee4ded848884be6d407.png" alt="j"><font><font>- has counted a number equal to the inverse of the permutation </font></font><img class="tex" src="./Fast Fourier transform _files/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"><font><font>bits. </font><font>Then, during the transition to the next number </font></font><img class="tex" src="./Fast Fourier transform _files/4ec332d2c63d7695c3b676e8e6dd9881.png" alt="i + 1"><font><font>we have and the number </font></font><img class="tex" src="./Fast Fourier transform _files/f2761432c5377ee4ded848884be6d407.png" alt="j"><font><font>add one, but add it to this "inverted" notation. </font><font>In a typical binary system add one - so remove all the units standing on the end of the number (ie, younger group of units), and put the unit in front of them. </font><font>Accordingly, in the "inverted" system, we have to go by the number of bits, starting with the oldest, and as long as there are units, remove them and move on to the next bit; </font><font>when it will meet the first zero bit, to put it one and stop.</font></font></p><p><font><font>So we get a realization:</font></font></p><p></p><pre class="notranslate cpp"><span class="kw4">typedef</span> complex<span class="sy1">&lt;</span><span class="kw4">double</span><span class="sy1">&gt;</span> base<span class="sy4">;</span>
&nbsp;
<span class="kw4">void</span> fft <span class="br0">(</span>vector<span class="sy1">&lt;</span>base<span class="sy1">&gt;</span> <span class="sy3">&amp;</span> a, <span class="kw4">bool</span> invert<span class="br0">)</span> <span class="br0">{</span>
	<span class="kw4">int</span> n <span class="sy1">=</span> <span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> a.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">1</span>, j<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">)</span> <span class="br0">{</span>
		<span class="kw4">int</span> bit <span class="sy1">=</span> n <span class="sy1">&gt;&gt;</span> <span class="nu0">1</span><span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">(</span><span class="sy4">;</span> j<span class="sy1">&gt;=</span>bit<span class="sy4">;</span> bit<span class="sy1">&gt;&gt;=</span><span class="nu0">1</span><span class="br0">)</span>
			j <span class="sy2">-</span><span class="sy1">=</span> bit<span class="sy4">;</span>
		j <span class="sy2">+</span><span class="sy1">=</span> bit<span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">(</span>i <span class="sy1">&lt;</span> j<span class="br0">)</span>
			swap <span class="br0">(</span>a<span class="br0">[</span>i<span class="br0">]</span>, a<span class="br0">[</span>j<span class="br0">]</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="br0">}</span>
&nbsp;
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> len<span class="sy1">=</span><span class="nu0">2</span><span class="sy4">;</span> len<span class="sy1">&lt;=</span>n<span class="sy4">;</span> len<span class="sy1">&lt;&lt;=</span><span class="nu0">1</span><span class="br0">)</span> <span class="br0">{</span>
		<span class="kw4">double</span> ang <span class="sy1">=</span> <span class="nu0">2</span><span class="sy2">*</span>PI<span class="sy2">/</span>len <span class="sy2">*</span> <span class="br0">(</span>invert <span class="sy4">?</span> <span class="sy2">-</span><span class="nu0">1</span> <span class="sy4">:</span> <span class="nu0">1</span><span class="br0">)</span><span class="sy4">;</span>
		base wlen <span class="br0">(</span><span class="kw3">cos</span><span class="br0">(</span>ang<span class="br0">)</span>, <span class="kw3">sin</span><span class="br0">(</span>ang<span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> i<span class="sy2">+</span><span class="sy1">=</span>len<span class="br0">)</span> <span class="br0">{</span>
			base w <span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy4">;</span>
			<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> j<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> j<span class="sy1">&lt;</span>len<span class="sy2">/</span><span class="nu0">2</span><span class="sy4">;</span> <span class="sy2">++</span>j<span class="br0">)</span> <span class="br0">{</span>
				base u <span class="sy1">=</span> a<span class="br0">[</span>i<span class="sy2">+</span>j<span class="br0">]</span>,  v <span class="sy1">=</span> a<span class="br0">[</span>i<span class="sy2">+</span>j<span class="sy2">+</span>len<span class="sy2">/</span><span class="nu0">2</span><span class="br0">]</span> <span class="sy2">*</span> w<span class="sy4">;</span>
				a<span class="br0">[</span>i<span class="sy2">+</span>j<span class="br0">]</span> <span class="sy1">=</span> u <span class="sy2">+</span> v<span class="sy4">;</span>
				a<span class="br0">[</span>i<span class="sy2">+</span>j<span class="sy2">+</span>len<span class="sy2">/</span><span class="nu0">2</span><span class="br0">]</span> <span class="sy1">=</span> u <span class="sy2">-</span> v<span class="sy4">;</span>
				w <span class="sy2">*</span><span class="sy1">=</span> wlen<span class="sy4">;</span>
			<span class="br0">}</span>
		<span class="br0">}</span>
	<span class="br0">}</span>
	<span class="kw1">if</span> <span class="br0">(</span>invert<span class="br0">)</span>
		<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">)</span>
			a<span class="br0">[</span>i<span class="br0">]</span> <span class="sy2">/</span><span class="sy1">=</span> n<span class="sy4">;</span>
<span class="br0">}</span></pre><p></p><p></p><a name="7"></a><h2 style="padding-top:40px;" id="header_7"><font><font> Additional optimization </font></font></h2><p><font><font>We give a list of other optimizations, which together can significantly accelerate given above "enhanced" implementation:</font></font></p><p></p><ul><p></p><li><b><font><font>Predposchitat Reverse bits</font></font></b><font><font> for all numbers in a global table. </font><font>This is especially easy when the size </font></font><img class="tex" src="./Fast Fourier transform _files/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"><font><font>for all calls the same.</font></font><p><font><font>This optimization becomes appreciable when a large number of </font></font><img class="tex" src="./Fast Fourier transform _files/d6c92bc69cebabac3eadda2d0cf0053f.png" alt="fft ()"><font><font>calls. </font><font>However, the effect of it can be seen even at the three calls (three calls - the most common situation, that is when you need a time to multiply two polynomials).</font></font></p><p></p></li><li><font><font>Refuse to use </font></font><img class="tex" src="./Fast Fourier transform _files/34f8b10596e5ad6a9b0d89adee5103d1.png" alt="\ rm vector"><font><font>(go to regular </font><font>arrays).</font></font><b><font></font></b><font></font><p><font><font>The effect of this depends upon the particular compiler, but typically it is present and is approximately 10% -20%.</font></font></p><p></p></li><li><font><font>Predposchitat </font></font><b><font><font>all degrees</font></font></b><font><font> </font></font><img class="tex" src="./Fast Fourier transform _files/986001e31b752a6225d355b07eb01fb1.png" alt="wlen"><font><font>of. </font><font>In fact, in this cycle of the algorithm repeatedly made pass all the powers of </font></font><img class="tex" src="./Fast Fourier transform _files/986001e31b752a6225d355b07eb01fb1.png" alt="wlen"><font><font>from </font><font>to:</font></font><img class="tex" src="./Fast Fourier transform _files/d796aaaffd5bff4144c8ac3509c1d33d.png" alt="0"><font></font><img class="tex" src="./Fast Fourier transform _files/c5d5c263e97733d7b240423537f05d37.png" alt="len / 2-1"><font></font><p></p><pre class="notranslate cpp">		<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> i<span class="sy2">+</span><span class="sy1">=</span>len<span class="br0">)</span> <span class="br0">{</span>
			base w <span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy4">;</span>
			<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> j<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> j<span class="sy1">&lt;</span>len<span class="sy2">/</span><span class="nu0">2</span><span class="sy4">;</span> <span class="sy2">++</span>j<span class="br0">)</span> <span class="br0">{</span>
				<span class="br0">[</span>...<span class="br0">]</span>
				w <span class="sy2">*</span><span class="sy1">=</span> wlen<span class="sy4">;</span>
			<span class="br0">}</span>
		<span class="br0">}</span></pre><p><font><font>Accordingly, before this cycle we can predposchitat in a array of all the required extent, and thus to get rid of unnecessary multiplications of nested loops.</font></font></p><p><font><font>Tentative acceleration - 5-10%.</font></font></p><p></p></li><li><font><font>Get rid of </font></font><b><font><font>references to arrays of </font></font></b><font><font>indices, </font><font>instead use a pointer to the current element of the array by promoting their right to 1 on each iteration.</font></font><p><font><font>At first glance, optimizing compilers should be able to cope with this, but in practice it turns out that the replacement of references to arrays </font></font><img class="tex" src="./Fast Fourier transform _files/ad9dc6bfe8abaec4ab385419457c3a6e.png" alt="a [i + j]"><font><font>and </font></font><img class="tex" src="./Fast Fourier transform _files/1db09b2df88a0ce1245e3f6ab3447d3f.png" alt="a [i + j + len / 2]"><font><font>pointers in the program accelerates common compilers. </font><font>Winning is 5-10%.</font></font></p><p></p></li><li><b><font><font>Reject the standard type of complex </font></font></b> <img class="tex" src="./Fast Fourier transform _files/2a3e1e044ef99df5524ab2c5d81444f8.png" alt="\ rm complex"><font><font>numbers, </font><font>put it into your own implementation.</font></font><p><font><font>Again, this may seem surprising, but even in modern compilers gain from such rewriting can be up to several tens of percent! </font><font>This indirectly confirms a widespread claim that the compilers worse cope with formulaic data types, optimizing the work with them is much worse than a no template types.</font></font></p><p></p></li><li><font><font>Another useful optimization is the </font></font><b><font><font>cut-off length</font></font></b><font><font> when the length of the working unit becomes small (say, 4) to calculate the DFT for it "by hand". </font><font>If you paint these cases in the form of explicit formulas for the length equal </font></font><img class="tex" src="./Fast Fourier transform _files/2f54b964e9395dd3e3900f753a28af80.png" alt="4/2"><font><font>to, </font><font>the values of the sine-cosine take integer values, due to which you can get a speed boost for a few more tens of percent.</font></font><p></p></li></ul><p><font><font>Here we present the realization of the described improvements (except for the last two points, which lead to the proliferation of code):</font></font></p><p></p><pre class="notranslate cpp"><span class="kw4">int</span> rev<span class="br0">[</span>MAXN<span class="br0">]</span><span class="sy4">;</span>
base wlen_pw<span class="br0">[</span>MAXN<span class="br0">]</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">void</span> fft <span class="br0">(</span>base a<span class="br0">[</span><span class="br0">]</span>, <span class="kw4">int</span> n, <span class="kw4">bool</span> invert<span class="br0">)</span> <span class="br0">{</span>
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">)</span>
		<span class="kw1">if</span> <span class="br0">(</span>i <span class="sy1">&lt;</span> rev<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span>
			swap <span class="br0">(</span>a<span class="br0">[</span>i<span class="br0">]</span>, a<span class="br0">[</span>rev<span class="br0">[</span>i<span class="br0">]</span><span class="br0">]</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> len<span class="sy1">=</span><span class="nu0">2</span><span class="sy4">;</span> len<span class="sy1">&lt;=</span>n<span class="sy4">;</span> len<span class="sy1">&lt;&lt;=</span><span class="nu0">1</span><span class="br0">)</span> <span class="br0">{</span>
		<span class="kw4">double</span> ang <span class="sy1">=</span> <span class="nu0">2</span><span class="sy2">*</span>PI<span class="sy2">/</span>len <span class="sy2">*</span> <span class="br0">(</span>invert<span class="sy4">?</span><span class="sy2">-</span><span class="nu0">1</span><span class="sy4">:</span><span class="sy2">+</span><span class="nu0">1</span><span class="br0">)</span><span class="sy4">;</span>
		<span class="kw4">int</span> len2 <span class="sy1">=</span> len<span class="sy1">&gt;&gt;</span><span class="nu0">1</span><span class="sy4">;</span>
&nbsp;
		base wlen <span class="br0">(</span><span class="kw3">cos</span><span class="br0">(</span>ang<span class="br0">)</span>, <span class="kw3">sin</span><span class="br0">(</span>ang<span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
		wlen_pw<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy1">=</span> base <span class="br0">(</span><span class="nu0">1</span>, <span class="nu0">0</span><span class="br0">)</span><span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">1</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>len2<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">)</span>
			wlen_pw<span class="br0">[</span>i<span class="br0">]</span> <span class="sy1">=</span> wlen_pw<span class="br0">[</span>i<span class="sy2">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy2">*</span> wlen<span class="sy4">;</span>
&nbsp;
		<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> i<span class="sy2">+</span><span class="sy1">=</span>len<span class="br0">)</span> <span class="br0">{</span>
			base t,
				<span class="sy2">*</span>pu <span class="sy1">=</span> a<span class="sy2">+</span>i,
				<span class="sy2">*</span>pv <span class="sy1">=</span> a<span class="sy2">+</span>i<span class="sy2">+</span>len2, 
				<span class="sy2">*</span>pu_end <span class="sy1">=</span> a<span class="sy2">+</span>i<span class="sy2">+</span>len2,
				<span class="sy2">*</span>pw <span class="sy1">=</span> wlen_pw<span class="sy4">;</span>
			<span class="kw1">for</span> <span class="br0">(</span><span class="sy4">;</span> pu<span class="sy3">!</span><span class="sy1">=</span>pu_end<span class="sy4">;</span> <span class="sy2">++</span>pu, <span class="sy2">++</span>pv, <span class="sy2">++</span>pw<span class="br0">)</span> <span class="br0">{</span>
				t <span class="sy1">=</span> <span class="sy2">*</span>pv <span class="sy2">*</span> <span class="sy2">*</span>pw<span class="sy4">;</span>
				<span class="sy2">*</span>pv <span class="sy1">=</span> <span class="sy2">*</span>pu <span class="sy2">-</span> t<span class="sy4">;</span>
				<span class="sy2">*</span>pu <span class="sy2">+</span><span class="sy1">=</span> t<span class="sy4">;</span>
			<span class="br0">}</span>
		<span class="br0">}</span>
	<span class="br0">}</span>
&nbsp;
	<span class="kw1">if</span> <span class="br0">(</span>invert<span class="br0">)</span>
		<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">)</span>
			a<span class="br0">[</span>i<span class="br0">]</span> <span class="sy2">/</span><span class="sy1">=</span> n<span class="sy4">;</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">void</span> calc_rev <span class="br0">(</span><span class="kw4">int</span> n, <span class="kw4">int</span> log_n<span class="br0">)</span> <span class="br0">{</span>
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">)</span> <span class="br0">{</span>
		rev<span class="br0">[</span>i<span class="br0">]</span> <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> j<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> j<span class="sy1">&lt;</span>log_n<span class="sy4">;</span> <span class="sy2">++</span>j<span class="br0">)</span>
			<span class="kw1">if</span> <span class="br0">(</span>i <span class="sy3">&amp;</span> <span class="br0">(</span><span class="nu0">1</span><span class="sy1">&lt;&lt;</span>j<span class="br0">)</span><span class="br0">)</span>
				rev<span class="br0">[</span>i<span class="br0">]</span> <span class="sy3">|</span><span class="sy1">=</span> <span class="nu0">1</span><span class="sy1">&lt;&lt;</span><span class="br0">(</span>log_n<span class="sy2">-</span><span class="nu0">1</span><span class="sy2">-</span>j<span class="br0">)</span><span class="sy4">;</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre><p><font><font>In this common compilers faster than the previous implementation of an "improved" version of 2-3.</font></font></p><p></p><p></p><a name="8"></a><h2 style="padding-top:40px;" id="header_8"><font><font> Discrete Fourier transform in a modular arithmetic </font></font></h2><p><font><font>At the heart of the discrete Fourier transform are complex numbers, the roots </font></font><img class="tex" src="./Fast Fourier transform _files/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"><font><font>th of unity. </font><font>To effectively calculate it used features such roots, as the existence of </font></font><img class="tex" src="./Fast Fourier transform _files/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"><font><font>different roots, forming a group (ie the degree of root - always another root among them there is one element - the generator of the group, called a primitive root).</font></font></p><p><font><font>But the same is true of the roots of </font></font><img class="tex" src="./Fast Fourier transform _files/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"><font><font>th degree of unity in modular arithmetic. </font><font>More precisely, not for any module </font></font><img class="tex" src="./Fast Fourier transform _files/2f8934466bea85c9661745280df23800.png" alt="p"><font><font>there exists a </font></font><img class="tex" src="./Fast Fourier transform _files/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"><font><font>distinct roots of unity, however, these units still exist. </font><font>Still it is important to find among them a primitive root, ie .:</font></font></p><p></p><p class="formula"><img class="tex" src="./Fast Fourier transform _files/54beb7122de9abe0dfc40217bdaa489f.png" alt=" (w_n) ^ n = 1 \ pmod p, "><br><img class="tex" src="./Fast Fourier transform _files/99c6f6e83dfa048916359626a67fce5e.png" alt=" (w_n) ^ k \ ne 1 {\ pmod p}, ~~~~~ 1 \ le k &lt;n. "></p><p><font><font>All remaining </font></font><img class="tex" src="./Fast Fourier transform _files/0409310e642143903bd490e71e4a951e.png" alt="n-1"><font><font>roots </font></font><img class="tex" src="./Fast Fourier transform _files/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"><font><font>th of unity in absolute value </font></font><img class="tex" src="./Fast Fourier transform _files/2f8934466bea85c9661745280df23800.png" alt="p"><font><font>can be obtained as the degree of the primitive root </font></font><img class="tex" src="./Fast Fourier transform _files/f12b737c8c65734e041f13f902fce36a.png" alt="w_n"><font><font>(as in the complex case).</font></font></p><p><font><font>For use in the fast Fourier transform algorithm we needed to root primivny existed for </font></font><img class="tex" src="./Fast Fourier transform _files/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"><font><font>some, </font><font>a power of two, as well as all the smaller degrees. </font><font>And if in the complex case, there was a primitive root for </font></font><img class="tex" src="./Fast Fourier transform _files/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"><font><font>all, </font><font>in the case of modular arithmetic is, generally speaking, not true. </font><font>However, note that </font></font><img class="tex" src="./Fast Fourier transform _files/b09e0620fa231823bd22c4bce636cb20.png" alt="n = 2 ^ k"><font><font>if, </font><font>that </font></font><img class="tex" src="./Fast Fourier transform _files/252410059470b019db6fd4c3b844a348.png" alt="k"><font><font>Star power of two, then the module </font></font><img class="tex" src="./Fast Fourier transform _files/542697e97c5bdd71ab45c84bf63d4599.png" alt="m = 2 ^ {k-1}"><font><font>we have:</font></font></p><p></p><p class="formula"><img class="tex" src="./Fast Fourier transform _files/0d55283e79a32ad821ba3e8761856e99.png" alt=" (w_n ^ 2) ^ m = (w_n) ^ n = 1 \ pmod p, "><br><img class="tex" src="./Fast Fourier transform _files/bd564076c8f0f342329c19cfffa49913.png" alt=" (w_n ^ 2) ^ k = w_n ^ {2k} \ ne 1 {\ pmod p}, ~~~~~ 1 \ le [...]"></p><p><font><font>Thus, if </font></font><img class="tex" src="./Fast Fourier transform _files/f12b737c8c65734e041f13f902fce36a.png" alt="w_n"><font><font>- a primitive </font></font><img class="tex" src="./Fast Fourier transform _files/ca4d42af0cda4cba14f030af06e82669.png" alt="n = 2 ^ k"><font><font>root-th </font><font>degree of unity, then </font></font><img class="tex" src="./Fast Fourier transform _files/71631eff088d00cdeb713d1f2c23ac59.png" alt="w_n ^ 2"><font><font>- primitive root </font></font><img class="tex" src="./Fast Fourier transform _files/97c42e4ca4ce993e5a52c7ece2343aaa.png" alt="2 ^ {k-1}"><font><font>th of unity. </font><font>Consequently, for all powers of two </font></font><img class="tex" src="./Fast Fourier transform _files/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"><font><font>smaller, </font><font>the desired degree of primitive roots also exist and can be calculated as the corresponding </font></font><img class="tex" src="./Fast Fourier transform _files/f12b737c8c65734e041f13f902fce36a.png" alt="w_n"><font><font>extent.</font></font></p><p><font><font>The final touch - for inverse DFT we used instead of </font></font><img class="tex" src="./Fast Fourier transform _files/f12b737c8c65734e041f13f902fce36a.png" alt="w_n"><font><font>inverse </font></font><img class="tex" src="./Fast Fourier transform _files/e42ff37eaeded937d425915bec3785f4.png" alt="w_n ^ {- 1}"><font><font>element:. </font><font>But modulo </font></font><img class="tex" src="./Fast Fourier transform _files/2f8934466bea85c9661745280df23800.png" alt="p"><font><font>inverse is also always a.</font></font></p><p><font><font>Thus, all the necessary properties are observed in the case of modular arithmetic, provided that we have chosen some rather large </font></font><img class="tex" src="./Fast Fourier transform _files/2f8934466bea85c9661745280df23800.png" alt="p"><font><font>unit, </font><font>and found in it a primitive root </font></font><img class="tex" src="./Fast Fourier transform _files/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"><font><font>th of unity.</font></font></p><p><font><font>For example, you can take the following values: a </font><font>module,. </font><font>If this module is not enough to find another pair, you can use the fact that the module type </font><font>(but still necessarily simple) there will always be a primitive root of degree </font><font>of unity.</font></font><img class="tex" src="./Fast Fourier transform _files/59f73131909c16cd8716241ba09be567.png" alt="p = 7340033"><font></font><img class="tex" src="./Fast Fourier transform _files/a523adba4d4099815209c03b64762b27.png" alt="w_ {2 ^ {20}} = 5"><font></font><img class="tex" src="./Fast Fourier transform _files/7a78e35b111a54289d4ba09778d3b979.png" alt="2 c ^ k + 1"><font></font><img class="tex" src="./Fast Fourier transform _files/a631b6ee74bdfc6711813da7ca95a648.png" alt="2 ^ k"><font></font></p><p></p><pre class="notranslate cpp"><span class="kw4">const</span> <span class="kw4">int</span> mod <span class="sy1">=</span> <span class="nu0">7340033</span><span class="sy4">;</span>
<span class="kw4">const</span> <span class="kw4">int</span> root <span class="sy1">=</span> <span class="nu0">5</span><span class="sy4">;</span>
<span class="kw4">const</span> <span class="kw4">int</span> root_1 <span class="sy1">=</span> <span class="nu0">4404020</span><span class="sy4">;</span>
<span class="kw4">const</span> <span class="kw4">int</span> root_pw <span class="sy1">=</span> <span class="nu0">1</span><span class="sy1">&lt;&lt;</span><span class="nu0">20</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">void</span> fft <span class="br0">(</span>vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> <span class="sy3">&amp;</span> a, <span class="kw4">bool</span> invert<span class="br0">)</span> <span class="br0">{</span>
	<span class="kw4">int</span> n <span class="sy1">=</span> <span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> a.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">1</span>, j<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">)</span> <span class="br0">{</span>
		<span class="kw4">int</span> bit <span class="sy1">=</span> n <span class="sy1">&gt;&gt;</span> <span class="nu0">1</span><span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">(</span><span class="sy4">;</span> j<span class="sy1">&gt;=</span>bit<span class="sy4">;</span> bit<span class="sy1">&gt;&gt;=</span><span class="nu0">1</span><span class="br0">)</span>
			j <span class="sy2">-</span><span class="sy1">=</span> bit<span class="sy4">;</span>
		j <span class="sy2">+</span><span class="sy1">=</span> bit<span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">(</span>i <span class="sy1">&lt;</span> j<span class="br0">)</span>
			swap <span class="br0">(</span>a<span class="br0">[</span>i<span class="br0">]</span>, a<span class="br0">[</span>j<span class="br0">]</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="br0">}</span>
&nbsp;
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> len<span class="sy1">=</span><span class="nu0">2</span><span class="sy4">;</span> len<span class="sy1">&lt;=</span>n<span class="sy4">;</span> len<span class="sy1">&lt;&lt;=</span><span class="nu0">1</span><span class="br0">)</span> <span class="br0">{</span>
		<span class="kw4">int</span> wlen <span class="sy1">=</span> invert <span class="sy4">?</span> root_1 <span class="sy4">:</span> root<span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy1">=</span>len<span class="sy4">;</span> i<span class="sy1">&lt;</span>root_pw<span class="sy4">;</span> i<span class="sy1">&lt;&lt;=</span><span class="nu0">1</span><span class="br0">)</span>
			wlen <span class="sy1">=</span> <span class="kw4">int</span> <span class="br0">(</span>wlen <span class="sy2">*</span> 1ll <span class="sy2">*</span> wlen <span class="sy2">%</span> mod<span class="br0">)</span><span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> i<span class="sy2">+</span><span class="sy1">=</span>len<span class="br0">)</span> <span class="br0">{</span>
			<span class="kw4">int</span> w <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
			<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> j<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> j<span class="sy1">&lt;</span>len<span class="sy2">/</span><span class="nu0">2</span><span class="sy4">;</span> <span class="sy2">++</span>j<span class="br0">)</span> <span class="br0">{</span>
				<span class="kw4">int</span> u <span class="sy1">=</span> a<span class="br0">[</span>i<span class="sy2">+</span>j<span class="br0">]</span>,  v <span class="sy1">=</span> <span class="kw4">int</span> <span class="br0">(</span>a<span class="br0">[</span>i<span class="sy2">+</span>j<span class="sy2">+</span>len<span class="sy2">/</span><span class="nu0">2</span><span class="br0">]</span> <span class="sy2">*</span> 1ll <span class="sy2">*</span> w <span class="sy2">%</span> mod<span class="br0">)</span><span class="sy4">;</span>
				a<span class="br0">[</span>i<span class="sy2">+</span>j<span class="br0">]</span> <span class="sy1">=</span> u<span class="sy2">+</span>v <span class="sy1">&lt;</span> mod <span class="sy4">?</span> u<span class="sy2">+</span>v <span class="sy4">:</span> u<span class="sy2">+</span>v<span class="sy2">-</span>mod<span class="sy4">;</span>
				a<span class="br0">[</span>i<span class="sy2">+</span>j<span class="sy2">+</span>len<span class="sy2">/</span><span class="nu0">2</span><span class="br0">]</span> <span class="sy1">=</span> u<span class="sy2">-</span>v <span class="sy1">&gt;=</span> <span class="nu0">0</span> <span class="sy4">?</span> u<span class="sy2">-</span>v <span class="sy4">:</span> u<span class="sy2">-</span>v<span class="sy2">+</span>mod<span class="sy4">;</span>
				w <span class="sy1">=</span> <span class="kw4">int</span> <span class="br0">(</span>w <span class="sy2">*</span> 1ll <span class="sy2">*</span> wlen <span class="sy2">%</span> mod<span class="br0">)</span><span class="sy4">;</span>
			<span class="br0">}</span>
		<span class="br0">}</span>
	<span class="br0">}</span>
	<span class="kw1">if</span> <span class="br0">(</span>invert<span class="br0">)</span> <span class="br0">{</span>
		<span class="kw4">int</span> nrev <span class="sy1">=</span> reverse <span class="br0">(</span>n, mod<span class="br0">)</span><span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">)</span>
			a<span class="br0">[</span>i<span class="br0">]</span> <span class="sy1">=</span> <span class="kw4">int</span> <span class="br0">(</span>a<span class="br0">[</span>i<span class="br0">]</span> <span class="sy2">*</span> 1ll <span class="sy2">*</span> nrev <span class="sy2">%</span> mod<span class="br0">)</span><span class="sy4">;</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre><p><font><font>Here, the function </font></font><img class="tex" src="./Fast Fourier transform _files/1a5d1b394d00175648cba193ac491862.png" alt="\ rm reverse"><font><font>is the inverse of </font></font><img class="tex" src="./Fast Fourier transform _files/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"><font><font>an element of the module </font></font><img class="tex" src="./Fast Fourier transform _files/0f658920d255fe5d822d94a912891318.png" alt="\ rm mod"><font><font>(see. </font></font><a href="http://e-maxx.ru/algo/reverse_element"><font><font>The return element in the </font></font></a><font><font>modulo). </font><font>The </font></font><img class="tex" src="./Fast Fourier transform _files/0f658920d255fe5d822d94a912891318.png" alt="\ rm mod"><font><font>constants, </font><font>define a module and a primitive root, and </font><font>- a return to the </font><font>element of the </font><font>module.</font></font><img class="tex" src="./Fast Fourier transform _files/40e0e810bf54145c555375778ebb3918.png" alt="\ rm root"> <img class="tex" src="./Fast Fourier transform _files/7670cd6a51354cded32d8d4c70ce2233.png" alt="\ rm root \ _pw"><font></font><img class="tex" src="./Fast Fourier transform _files/474339a5ad9c59e050089b9daa1108b5.png" alt="\ rm root \ _1"><font></font><img class="tex" src="./Fast Fourier transform _files/40e0e810bf54145c555375778ebb3918.png" alt="\ rm root"><font></font><img class="tex" src="./Fast Fourier transform _files/0f658920d255fe5d822d94a912891318.png" alt="\ rm mod"><font></font></p><p><font><font>As practice shows, the implementation of integral DFT works even slower implementation of complex numbers (because of the huge number of operations modulo), but it has advantages such as less memory usage and the absence of rounding errors.</font></font></p><p></p><p></p><a name="9"></a><h2 style="padding-top:40px;" id="header_9"><font><font> Some applications </font></font></h2><p><font><font>In addition to the direct application to the multiplication of polynomials or long numbers, we describe here are some other applications of the discrete Fourier transform.</font></font></p><p></p><p></p><a name="10"></a><h3 style="padding-top:15px;" id="header_10"><font><font> All sums </font></font></h3><p><font><font>The problem: given two arrays </font><font>and. </font><font>It is required to find all kinds of species </font><font>, and for each such numbers bring the number of ways to get it.</font></font><img class="tex" src="./Fast Fourier transform _files/0f0e294f3fa9d716ea988ff8370f698d.png" alt="a []"><font></font><img class="tex" src="./Fast Fourier transform _files/8112797623a2578c9b348cfa624f6f79.png" alt="b []"><font></font><img class="tex" src="./Fast Fourier transform _files/0f35d1a20408744c92470de9cf7bb042.png" alt="a [i] + b [j]"><font></font></p><p><font><font>For example, for </font></font><img class="tex" src="./Fast Fourier transform _files/65d903f1ae7bcdfa82a27f12efcd31c8.png" alt="a = (1,2,3)"><font><font>and </font></font><img class="tex" src="./Fast Fourier transform _files/b6de7a94d6a9070aedde76d3b261586f.png" alt="b = (2,4)"><font><font>obtain the number of 3 may be prepared 1 by 4 - and one, 5 - 2, 6 - 1 7 - 1.</font></font></p><p><font><font>We construct the arrays </font></font><img class="tex" src="./Fast Fourier transform _files/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"><font><font>and </font></font><img class="tex" src="./Fast Fourier transform _files/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b"><font><font>two polynomials </font></font><img class="tex" src="./Fast Fourier transform _files/b5f17df636a8bd667d2f5c3404ed82e7.png" alt="A"><font><font>and </font></font><img class="tex" src="./Fast Fourier transform _files/fb8234db4e6ea317a7c2aef7a38775ba.png" alt="B"><font><font>. </font><font>As the degrees of the polynomial will be performing numbers themselves, ie, </font><font>values </font></font><img class="tex" src="./Fast Fourier transform _files/3530c8c1281c8ee618b020a2333a22ca.png" alt="a [i]"><font><font>(), and as the coefficients of them - the number of times this number is found in the array </font><font>().</font></font><img class="tex" src="./Fast Fourier transform _files/e875235207203e3980be2bd509460e7a.png" alt="b [i]"><font></font><img class="tex" src="./Fast Fourier transform _files/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"><font></font><img class="tex" src="./Fast Fourier transform _files/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b"><font></font></p><p><font><font>Then, multiplying the two polynomials </font></font><img class="tex" src="./Fast Fourier transform _files/527d68b29319f540bf910dd5bb881008.png" alt="O (n \ log n)"><font><font>over, </font><font>we get the </font></font><img class="tex" src="./Fast Fourier transform _files/5572481c8713abb69ad4011419e91fc7.png" alt="C"><font><font>polynomial, </font><font>where the degrees are all kinds of </font></font><img class="tex" src="./Fast Fourier transform _files/0f35d1a20408744c92470de9cf7bb042.png" alt="a [i] + b [j]"><font><font>species, </font><font>and their coefficients are just the required number of</font></font></p><p></p><p></p><a name="11"></a><h3 style="padding-top:15px;" id="header_11"><font><font> All kinds of scalar products </font></font></h3><p><font><font>Given two array </font></font><img class="tex" src="./Fast Fourier transform _files/0f0e294f3fa9d716ea988ff8370f698d.png" alt="a []"><font><font>and </font></font><img class="tex" src="./Fast Fourier transform _files/8112797623a2578c9b348cfa624f6f79.png" alt="b []"><font><font>the same </font></font><img class="tex" src="./Fast Fourier transform _files/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"><font><font>length. </font><font>You want to display the values of each of the inner product of the vector </font></font><img class="tex" src="./Fast Fourier transform _files/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"><font><font>for the next cyclic shift of the </font></font><img class="tex" src="./Fast Fourier transform _files/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b"><font><font>vector.</font></font></p><p><font><font>Invert the array </font></font><img class="tex" src="./Fast Fourier transform _files/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"><font><font>and assign it to the end of the </font></font><img class="tex" src="./Fast Fourier transform _files/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"><font><font>zeros, and the array </font></font><img class="tex" src="./Fast Fourier transform _files/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b"><font><font>- simply assign yourself. </font><font>Then, multiply them as polynomials. </font><font>Now consider the coefficients of the product </font></font><img class="tex" src="./Fast Fourier transform _files/744ddd580d3dacc50790fa5b5e0b4435.png" alt="c [n \ ldots 2n-1]"><font><font>(as always, all the indices in the 0-indexed). </font><font>We have:</font></font></p><p></p><p class="formula"><img class="tex" src="./Fast Fourier transform _files/d7e32e6ede26056e2aaf351b7ef1de4c.png" alt=" c [k] = \ sum_ {i + j = k} a [i] b [j]. "></p><p><font><font>Since all the </font></font><img class="tex" src="./Fast Fourier transform _files/e77111c05fcc8869462e359c96e152c7.png" alt="a [i] = 0, \ i = n \ ldots 2n-1"><font><font>elements, </font><font>we obtain:</font></font></p><p></p><p class="formula"><img class="tex" src="./Fast Fourier transform _files/ec4dbda38ee816fd1a8d9c1b318b0a8e.png" alt=" c [k] = \ sum_ {i = 0} ^ {n-1} a [i] b [ki]. "></p><p><font><font>It is easy to see in this sum, it is the inner product of the vector </font></font><img class="tex" src="./Fast Fourier transform _files/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"><font><font>on </font></font><img class="tex" src="./Fast Fourier transform _files/c1a3c44eefee914a472a57b2be82e59b.png" alt="kn-1"><font><font>th cyclic shift. </font><font>Thus, these coefficients (since </font></font><img class="tex" src="./Fast Fourier transform _files/0409310e642143903bd490e71e4a951e.png" alt="n-1"><font><font>th and pumping </font></font><img class="tex" src="./Fast Fourier transform _files/8544b63735ac13dc1cad3999e9840daf.png" alt="2n-2"><font><font>of th) - is the answer to the problem.</font></font></p><p><font><font>The solution is obtained with the asymptotic </font></font><img class="tex" src="./Fast Fourier transform _files/65dae66ac82f684c5b24e464a8ca3610.png" alt="O (n \ log n)"><font><font>behavior.</font></font></p><p></p><p></p><a name="12"></a><h3 style="padding-top:15px;" id="header_12"><font><font> Two strips </font></font></h3><p><font><font>Given two strips defined as two Boolean (ie, numerical value of 0 or 1) array </font><font>and. </font><font>It is required to find all of these positions on the first strip, that if you make starting from this position, a second strip, in any place will not work </font><font>directly on both strips. </font><font>This problem can be restated thus: given a map of the strip, in the form of 0/1 - you can wake up in the cage or not, and are given a figure as a template (in the form of an array in which the 0 - no cell, 1 - is) required Find all positions in the strip, which can be attached figure.</font></font><img class="tex" src="./Fast Fourier transform _files/0f0e294f3fa9d716ea988ff8370f698d.png" alt="a []"><font></font><img class="tex" src="./Fast Fourier transform _files/8112797623a2578c9b348cfa624f6f79.png" alt="b []"><font></font><img class="tex" src="./Fast Fourier transform _files/d04c5eb60a53293d4878d3c73c349aa6.png" alt="\ rm true"><font></font></p><p><font><font>This problem is actually no different from the previous problem - the problem of the scalar product. </font><font>Indeed, the dot product of two arrays 0/1 - a number of elements in which both were unity. </font><font>Our goal is to find all the cyclic shifts of the second sheet so that there was not a single element in which at least two strips were unity. </font><font>Ie </font><font>we must find all the cyclic shifts of the second array in which the inner product is zero.</font></font></p><p><font><font>Thus, this problem we decided </font></font><img class="tex" src="./Fast Fourier transform _files/527d68b29319f540bf910dd5bb881008.png" alt="O (n \ log n)"><font><font>for.</font></font></p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
</p><div id="disqus_thread"><iframe id="dsq-app1" name="dsq-app1" allowtransparency="true" frameborder="0" scrolling="no" tabindex="0" title="Disqus" width="100%" src="./Fast Fourier transform _files/saved_resource.html" style="width: 100% !important; border: none !important; overflow: hidden !important; height: 3653px !important;" horizontalscrolling="no" verticalscrolling="no"></iframe></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></tbody></table></body></html>